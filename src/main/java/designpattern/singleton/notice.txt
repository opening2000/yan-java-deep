1单例（Singleton）模式：单例模式确保某一个类只有一个 实例，而且该类只能是自己 实例化自己并向其他类公开 这个实例的对象创建 模式
     采用单例模式的类:根据单例模式知道其要满足以下三点
     1. 确保某一个类只有一个实例
     2. 而且自己实例化
     3. 并向其他类提供这个实例类 。 

2确保以上三点的所采用的编程策略 
    * 把构造方法声明为Private。确保只能由自己创建，避免外部创建实例或者被子类继承从而创造额外实例；
    * 定义一个私有静态的该类的实例作为该类的数据域。确保一个类只能有一个实例；
    *定义一个静态 工厂方法。外部类不能实例化一个该类的对象，所以只能用Static 的方法，提供给其他类调用，返回此单例类唯一的实例。

3、使用单例模式的条件:
     使用单例模式有一个必要条件：在一个系统要求一个类只有一个实例时才应当使用单例模式，反过来说，如果一个类可以有几个实例共存，那么就没有必要使用单例模式类。


java语言中单例类的一个最重要的特点是类的构造方法是私有的，从而避免外界利用构造子直接创建出任意多的实例。
因为构造是私有的，因此此类不能被继承。主动式单例类在类加载的时候就实例化一个自己的对象。


与主动式单例类相同的是，被动式单例类的构造方法是私有的，
不同的是在第一次被引用时才将自己实例化，如果加载器是静态的，那么在被动式单例类被加载时不会将自己实例化。

饿汉式单例类.在类初始化时，已经自行实例化
懒汉式单例类.在第一次调用的时候实例化

登记式单例
http://www.cnblogs.com/whgw/archive/2011/10/05/2199535.html


饿汉式单例类可以在Java语言内实现，但不易在C++内实现，
因为静态初始化在C++里没有固定的顺序，因而静态的m_instance变量的初始化与类的加载顺序没有保证，
可能会出问题。这就是为什么GoF在提出单例类的概念时，举的例子是懒汉式的。他们的书影响之大，
以致Java语言中单例类的例子也大多是懒汉式的。实际上，本书认为饿汉式单例类更符合Java语言本身的特点。





